

## ks -> Thpe
 - who is going to change printODE into "diagnostics" ?
 -> ThPe, done. 
    - changed also print to cat where appropriate
    - added rudimentary diagnostics for rk

 - BUT, diagnostics is still an ugly function.
   We may ?? go to S3 later on, e.g type -> class
   Note that one out can have several simultanaeous S3 classes,
   something like:

 class(out) <- c("matrix", "deSolve", "deSolvelsoda")


 - provide some "diagnostics" for runge-kutta functions, although they are quite trivial:
    - number of steps
    done

    - size of time step
    ** todo **

    - number of function evaluations
    done


## ThPe -> ThPe

- fix stack imbalance in case of aborted integration calls
  -> fixed for call_rk
  - check if there is a leak in lsoda??

- check function maxerr (minimal error!)

- implement PID step control

- ensure at least 4 internal steps for rk methods!! (neville-aitken)
  hmax = tmax - tmin / 4 (or better 5?)
  
- pass istate back to calling function
  -> done

- modularize rk_auto

- remove obsolete code

- check polynomial interpolation, error order and stepsize control again

- remove code that is doubled (deSolve_utils.c)
  -> done

- check hini, hmax, hmin
  - especially for rk4 !!

- write special version for euler (speedup)

- process rpar, ipar in all versions of call_rkxxxx


## KS --> ThPe

One of the reasons the interface in lsoda is more complex is because it
avoids the testing whether a function is a DLL ( inherits(func,
"NativeSymbol")) at each time step. So we do this only once.
--> done

I have the impression that output variables from C-code are not saved
here.
--> ThPe: I don't understand what you mean

Also, in lsoda, the "output variables" from R-code are set in R itself
(e.g. the function is called from R), not in C/fortran. 

I remember that I tested whether that affected performance, and it did
not - or was even slightly faster that way (and perhaps less memory is
also required). So I left it the way it was in odesolve. It avoids the
copying from/to C-variables. 
--> I see, but I leave it in C for now.

In C-code Nout is supposed to be a vector with at least 3 variables; in
your cderivs it appears to be one number?

- ThPe: yes, only the first element was passed
--> should work now; can you give me a test example??

## ThPe --> KS: adapt vignette that rk now supports DLL models
